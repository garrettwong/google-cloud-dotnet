// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: google/monitoring/v3/alert.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Google.Cloud.Monitoring.V3 {

  /// <summary>Holder for reflection information generated from google/monitoring/v3/alert.proto</summary>
  public static partial class AlertReflection {

    #region Descriptor
    /// <summary>File descriptor for google/monitoring/v3/alert.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static AlertReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CiBnb29nbGUvbW9uaXRvcmluZy92My9hbGVydC5wcm90bxIUZ29vZ2xlLm1v",
            "bml0b3JpbmcudjMaIWdvb2dsZS9tb25pdG9yaW5nL3YzL2NvbW1vbi5wcm90",
            "bxoqZ29vZ2xlL21vbml0b3JpbmcvdjMvbXV0YXRpb25fcmVjb3JkLnByb3Rv",
            "Gh5nb29nbGUvcHJvdG9idWYvZHVyYXRpb24ucHJvdG8aHmdvb2dsZS9wcm90",
            "b2J1Zi93cmFwcGVycy5wcm90bxoXZ29vZ2xlL3JwYy9zdGF0dXMucHJvdG8i",
            "gw0KC0FsZXJ0UG9saWN5EgwKBG5hbWUYASABKAkSFAoMZGlzcGxheV9uYW1l",
            "GAIgASgJEkYKDWRvY3VtZW50YXRpb24YDSABKAsyLy5nb29nbGUubW9uaXRv",
            "cmluZy52My5BbGVydFBvbGljeS5Eb2N1bWVudGF0aW9uEkYKC3VzZXJfbGFi",
            "ZWxzGBAgAygLMjEuZ29vZ2xlLm1vbml0b3JpbmcudjMuQWxlcnRQb2xpY3ku",
            "VXNlckxhYmVsc0VudHJ5Ej8KCmNvbmRpdGlvbnMYDCADKAsyKy5nb29nbGUu",
            "bW9uaXRvcmluZy52My5BbGVydFBvbGljeS5Db25kaXRpb24SSQoIY29tYmlu",
            "ZXIYBiABKA4yNy5nb29nbGUubW9uaXRvcmluZy52My5BbGVydFBvbGljeS5D",
            "b25kaXRpb25Db21iaW5lclR5cGUSKwoHZW5hYmxlZBgRIAEoCzIaLmdvb2ds",
            "ZS5wcm90b2J1Zi5Cb29sVmFsdWUSJAoIdmFsaWRpdHkYEiABKAsyEi5nb29n",
            "bGUucnBjLlN0YXR1cxIdChVub3RpZmljYXRpb25fY2hhbm5lbHMYDiADKAkS",
            "PQoPY3JlYXRpb25fcmVjb3JkGAogASgLMiQuZ29vZ2xlLm1vbml0b3Jpbmcu",
            "djMuTXV0YXRpb25SZWNvcmQSPQoPbXV0YXRpb25fcmVjb3JkGAsgASgLMiQu",
            "Z29vZ2xlLm1vbml0b3JpbmcudjMuTXV0YXRpb25SZWNvcmQaMwoNRG9jdW1l",
            "bnRhdGlvbhIPCgdjb250ZW50GAEgASgJEhEKCW1pbWVfdHlwZRgCIAEoCRr4",
            "BgoJQ29uZGl0aW9uEgwKBG5hbWUYDCABKAkSFAoMZGlzcGxheV9uYW1lGAYg",
            "ASgJEloKE2NvbmRpdGlvbl90aHJlc2hvbGQYASABKAsyOy5nb29nbGUubW9u",
            "aXRvcmluZy52My5BbGVydFBvbGljeS5Db25kaXRpb24uTWV0cmljVGhyZXNo",
            "b2xkSAASVQoQY29uZGl0aW9uX2Fic2VudBgCIAEoCzI5Lmdvb2dsZS5tb25p",
            "dG9yaW5nLnYzLkFsZXJ0UG9saWN5LkNvbmRpdGlvbi5NZXRyaWNBYnNlbmNl",
            "SAAaNQoHVHJpZ2dlchIPCgVjb3VudBgBIAEoBUgAEhEKB3BlcmNlbnQYAiAB",
            "KAFIAEIGCgR0eXBlGoEDCg9NZXRyaWNUaHJlc2hvbGQSDgoGZmlsdGVyGAIg",
            "ASgJEjcKDGFnZ3JlZ2F0aW9ucxgIIAMoCzIhLmdvb2dsZS5tb25pdG9yaW5n",
            "LnYzLkFnZ3JlZ2F0aW9uEhoKEmRlbm9taW5hdG9yX2ZpbHRlchgJIAEoCRJD",
            "ChhkZW5vbWluYXRvcl9hZ2dyZWdhdGlvbnMYCiADKAsyIS5nb29nbGUubW9u",
            "aXRvcmluZy52My5BZ2dyZWdhdGlvbhI4Cgpjb21wYXJpc29uGAQgASgOMiQu",
            "Z29vZ2xlLm1vbml0b3JpbmcudjMuQ29tcGFyaXNvblR5cGUSFwoPdGhyZXNo",
            "b2xkX3ZhbHVlGAUgASgBEisKCGR1cmF0aW9uGAYgASgLMhkuZ29vZ2xlLnBy",
            "b3RvYnVmLkR1cmF0aW9uEkQKB3RyaWdnZXIYByABKAsyMy5nb29nbGUubW9u",
            "aXRvcmluZy52My5BbGVydFBvbGljeS5Db25kaXRpb24uVHJpZ2dlchrLAQoN",
            "TWV0cmljQWJzZW5jZRIOCgZmaWx0ZXIYASABKAkSNwoMYWdncmVnYXRpb25z",
            "GAUgAygLMiEuZ29vZ2xlLm1vbml0b3JpbmcudjMuQWdncmVnYXRpb24SKwoI",
            "ZHVyYXRpb24YAiABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24SRAoH",
            "dHJpZ2dlchgDIAEoCzIzLmdvb2dsZS5tb25pdG9yaW5nLnYzLkFsZXJ0UG9s",
            "aWN5LkNvbmRpdGlvbi5UcmlnZ2VyQgsKCWNvbmRpdGlvbhoxCg9Vc2VyTGFi",
            "ZWxzRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4ASJhChVD",
            "b25kaXRpb25Db21iaW5lclR5cGUSFwoTQ09NQklORV9VTlNQRUNJRklFRBAA",
            "EgcKA0FORBABEgYKAk9SEAISHgoaQU5EX1dJVEhfTUFUQ0hJTkdfUkVTT1VS",
            "Q0UQA0KiAQoYY29tLmdvb2dsZS5tb25pdG9yaW5nLnYzQgpBbGVydFByb3Rv",
            "UAFaPmdvb2dsZS5nb2xhbmcub3JnL2dlbnByb3RvL2dvb2dsZWFwaXMvbW9u",
            "aXRvcmluZy92Mzttb25pdG9yaW5nqgIaR29vZ2xlLkNsb3VkLk1vbml0b3Jp",
            "bmcuVjPKAhpHb29nbGVcQ2xvdWRcTW9uaXRvcmluZ1xWM2IGcHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Google.Cloud.Monitoring.V3.CommonReflection.Descriptor, global::Google.Cloud.Monitoring.V3.MutationRecordReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.DurationReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.WrappersReflection.Descriptor, global::Google.Rpc.StatusReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Monitoring.V3.AlertPolicy), global::Google.Cloud.Monitoring.V3.AlertPolicy.Parser, new[]{ "Name", "DisplayName", "Documentation", "UserLabels", "Conditions", "Combiner", "Enabled", "Validity", "NotificationChannels", "CreationRecord", "MutationRecord" }, null, new[]{ typeof(global::Google.Cloud.Monitoring.V3.AlertPolicy.Types.ConditionCombinerType) }, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Monitoring.V3.AlertPolicy.Types.Documentation), global::Google.Cloud.Monitoring.V3.AlertPolicy.Types.Documentation.Parser, new[]{ "Content", "MimeType" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Monitoring.V3.AlertPolicy.Types.Condition), global::Google.Cloud.Monitoring.V3.AlertPolicy.Types.Condition.Parser, new[]{ "Name", "DisplayName", "ConditionThreshold", "ConditionAbsent" }, new[]{ "Condition" }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Monitoring.V3.AlertPolicy.Types.Condition.Types.Trigger), global::Google.Cloud.Monitoring.V3.AlertPolicy.Types.Condition.Types.Trigger.Parser, new[]{ "Count", "Percent" }, new[]{ "Type" }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Monitoring.V3.AlertPolicy.Types.Condition.Types.MetricThreshold), global::Google.Cloud.Monitoring.V3.AlertPolicy.Types.Condition.Types.MetricThreshold.Parser, new[]{ "Filter", "Aggregations", "DenominatorFilter", "DenominatorAggregations", "Comparison", "ThresholdValue", "Duration", "Trigger" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Monitoring.V3.AlertPolicy.Types.Condition.Types.MetricAbsence), global::Google.Cloud.Monitoring.V3.AlertPolicy.Types.Condition.Types.MetricAbsence.Parser, new[]{ "Filter", "Aggregations", "Duration", "Trigger" }, null, null, null)}),
            null, })
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// A description of the conditions under which some aspect of your system is
  /// considered to be "unhealthy" and the ways to notify people or services about
  /// this state. For an overview of alert policies, see
  /// [Introduction to Alerting](/monitoring/alerts/).
  /// </summary>
  public sealed partial class AlertPolicy : pb::IMessage<AlertPolicy> {
    private static readonly pb::MessageParser<AlertPolicy> _parser = new pb::MessageParser<AlertPolicy>(() => new AlertPolicy());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<AlertPolicy> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Monitoring.V3.AlertReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AlertPolicy() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AlertPolicy(AlertPolicy other) : this() {
      name_ = other.name_;
      displayName_ = other.displayName_;
      documentation_ = other.documentation_ != null ? other.documentation_.Clone() : null;
      userLabels_ = other.userLabels_.Clone();
      conditions_ = other.conditions_.Clone();
      combiner_ = other.combiner_;
      Enabled = other.Enabled;
      validity_ = other.validity_ != null ? other.validity_.Clone() : null;
      notificationChannels_ = other.notificationChannels_.Clone();
      creationRecord_ = other.creationRecord_ != null ? other.creationRecord_.Clone() : null;
      mutationRecord_ = other.mutationRecord_ != null ? other.mutationRecord_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AlertPolicy Clone() {
      return new AlertPolicy(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// Required if the policy exists. The resource name for this policy. The
    /// syntax is:
    ///
    ///     projects/[PROJECT_ID]/alertPolicies/[ALERT_POLICY_ID]
    ///
    /// `[ALERT_POLICY_ID]` is assigned by Stackdriver Monitoring when the policy
    /// is created.  When calling the
    /// [alertPolicies.create][google.monitoring.v3.AlertPolicyService.CreateAlertPolicy]
    /// method, do not include the `name` field in the alerting policy passed as
    /// part of the request.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "display_name" field.</summary>
    public const int DisplayNameFieldNumber = 2;
    private string displayName_ = "";
    /// <summary>
    /// A short name or phrase used to identify the policy in dashboards,
    /// notifications, and incidents. To avoid confusion, don't use the same
    /// display name for multiple policies in the same project. The name is
    /// limited to 512 Unicode characters.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string DisplayName {
      get { return displayName_; }
      set {
        displayName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "documentation" field.</summary>
    public const int DocumentationFieldNumber = 13;
    private global::Google.Cloud.Monitoring.V3.AlertPolicy.Types.Documentation documentation_;
    /// <summary>
    /// Documentation that is included with notifications and incidents related to
    /// this policy. Best practice is for the documentation to include information
    /// to help responders understand, mitigate, escalate, and correct the
    /// underlying problems detected by the alerting policy. Notification channels
    /// that have limited capacity might not show this documentation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Monitoring.V3.AlertPolicy.Types.Documentation Documentation {
      get { return documentation_; }
      set {
        documentation_ = value;
      }
    }

    /// <summary>Field number for the "user_labels" field.</summary>
    public const int UserLabelsFieldNumber = 16;
    private static readonly pbc::MapField<string, string>.Codec _map_userLabels_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForString(18), 130);
    private readonly pbc::MapField<string, string> userLabels_ = new pbc::MapField<string, string>();
    /// <summary>
    /// User-supplied key/value data to be used for organizing and
    /// identifying the `AlertPolicy` objects.
    ///
    /// The field can contain up to 64 entries. Each key and value is limited to
    /// 63 Unicode characters or 128 bytes, whichever is smaller. Labels and
    /// values can contain only lowercase letters, numerals, underscores, and
    /// dashes. Keys must begin with a letter.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, string> UserLabels {
      get { return userLabels_; }
    }

    /// <summary>Field number for the "conditions" field.</summary>
    public const int ConditionsFieldNumber = 12;
    private static readonly pb::FieldCodec<global::Google.Cloud.Monitoring.V3.AlertPolicy.Types.Condition> _repeated_conditions_codec
        = pb::FieldCodec.ForMessage(98, global::Google.Cloud.Monitoring.V3.AlertPolicy.Types.Condition.Parser);
    private readonly pbc::RepeatedField<global::Google.Cloud.Monitoring.V3.AlertPolicy.Types.Condition> conditions_ = new pbc::RepeatedField<global::Google.Cloud.Monitoring.V3.AlertPolicy.Types.Condition>();
    /// <summary>
    /// A list of conditions for the policy. The conditions are combined by AND or
    /// OR according to the `combiner` field. If the combined conditions evaluate
    /// to true, then an incident is created. A policy can have from one to six
    /// conditions.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.Cloud.Monitoring.V3.AlertPolicy.Types.Condition> Conditions {
      get { return conditions_; }
    }

    /// <summary>Field number for the "combiner" field.</summary>
    public const int CombinerFieldNumber = 6;
    private global::Google.Cloud.Monitoring.V3.AlertPolicy.Types.ConditionCombinerType combiner_ = 0;
    /// <summary>
    /// How to combine the results of multiple conditions to determine if an
    /// incident should be opened.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Monitoring.V3.AlertPolicy.Types.ConditionCombinerType Combiner {
      get { return combiner_; }
      set {
        combiner_ = value;
      }
    }

    /// <summary>Field number for the "enabled" field.</summary>
    public const int EnabledFieldNumber = 17;
    private static readonly pb::FieldCodec<bool?> _single_enabled_codec = pb::FieldCodec.ForStructWrapper<bool>(138);
    private bool? enabled_;
    /// <summary>
    /// Whether or not the policy is enabled. On write, the default interpretation
    /// if unset is that the policy is enabled. On read, clients should not make
    /// any assumption about the state if it has not been populated. The
    /// field should always be populated on List and Get operations, unless
    /// a field projection has been specified that strips it out.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool? Enabled {
      get { return enabled_; }
      set {
        enabled_ = value;
      }
    }


    /// <summary>Field number for the "validity" field.</summary>
    public const int ValidityFieldNumber = 18;
    private global::Google.Rpc.Status validity_;
    /// <summary>
    /// Read-only description of how the alert policy is invalid. OK if the alert
    /// policy is valid. If not OK, the alert policy will not generate incidents.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Rpc.Status Validity {
      get { return validity_; }
      set {
        validity_ = value;
      }
    }

    /// <summary>Field number for the "notification_channels" field.</summary>
    public const int NotificationChannelsFieldNumber = 14;
    private static readonly pb::FieldCodec<string> _repeated_notificationChannels_codec
        = pb::FieldCodec.ForString(114);
    private readonly pbc::RepeatedField<string> notificationChannels_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Identifies the notification channels to which notifications should be sent
    /// when incidents are opened or closed or when new violations occur on
    /// an already opened incident. Each element of this array corresponds to
    /// the `name` field in each of the
    /// [`NotificationChannel`][google.monitoring.v3.NotificationChannel]
    /// objects that are returned from the [`ListNotificationChannels`]
    /// [google.monitoring.v3.NotificationChannelService.ListNotificationChannels]
    /// method. The syntax of the entries in this field is:
    ///
    ///     projects/[PROJECT_ID]/notificationChannels/[CHANNEL_ID]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> NotificationChannels {
      get { return notificationChannels_; }
    }

    /// <summary>Field number for the "creation_record" field.</summary>
    public const int CreationRecordFieldNumber = 10;
    private global::Google.Cloud.Monitoring.V3.MutationRecord creationRecord_;
    /// <summary>
    /// A read-only record of the creation of the alerting policy. If provided
    /// in a call to create or update, this field will be ignored.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Monitoring.V3.MutationRecord CreationRecord {
      get { return creationRecord_; }
      set {
        creationRecord_ = value;
      }
    }

    /// <summary>Field number for the "mutation_record" field.</summary>
    public const int MutationRecordFieldNumber = 11;
    private global::Google.Cloud.Monitoring.V3.MutationRecord mutationRecord_;
    /// <summary>
    /// A read-only record of the most recent change to the alerting policy. If
    /// provided in a call to create or update, this field will be ignored.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Monitoring.V3.MutationRecord MutationRecord {
      get { return mutationRecord_; }
      set {
        mutationRecord_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as AlertPolicy);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(AlertPolicy other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (DisplayName != other.DisplayName) return false;
      if (!object.Equals(Documentation, other.Documentation)) return false;
      if (!UserLabels.Equals(other.UserLabels)) return false;
      if(!conditions_.Equals(other.conditions_)) return false;
      if (Combiner != other.Combiner) return false;
      if (Enabled != other.Enabled) return false;
      if (!object.Equals(Validity, other.Validity)) return false;
      if(!notificationChannels_.Equals(other.notificationChannels_)) return false;
      if (!object.Equals(CreationRecord, other.CreationRecord)) return false;
      if (!object.Equals(MutationRecord, other.MutationRecord)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (DisplayName.Length != 0) hash ^= DisplayName.GetHashCode();
      if (documentation_ != null) hash ^= Documentation.GetHashCode();
      hash ^= UserLabels.GetHashCode();
      hash ^= conditions_.GetHashCode();
      if (Combiner != 0) hash ^= Combiner.GetHashCode();
      if (enabled_ != null) hash ^= Enabled.GetHashCode();
      if (validity_ != null) hash ^= Validity.GetHashCode();
      hash ^= notificationChannels_.GetHashCode();
      if (creationRecord_ != null) hash ^= CreationRecord.GetHashCode();
      if (mutationRecord_ != null) hash ^= MutationRecord.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (DisplayName.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(DisplayName);
      }
      if (Combiner != 0) {
        output.WriteRawTag(48);
        output.WriteEnum((int) Combiner);
      }
      if (creationRecord_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(CreationRecord);
      }
      if (mutationRecord_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(MutationRecord);
      }
      conditions_.WriteTo(output, _repeated_conditions_codec);
      if (documentation_ != null) {
        output.WriteRawTag(106);
        output.WriteMessage(Documentation);
      }
      notificationChannels_.WriteTo(output, _repeated_notificationChannels_codec);
      userLabels_.WriteTo(output, _map_userLabels_codec);
      if (enabled_ != null) {
        _single_enabled_codec.WriteTagAndValue(output, Enabled);
      }
      if (validity_ != null) {
        output.WriteRawTag(146, 1);
        output.WriteMessage(Validity);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (DisplayName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DisplayName);
      }
      if (documentation_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Documentation);
      }
      size += userLabels_.CalculateSize(_map_userLabels_codec);
      size += conditions_.CalculateSize(_repeated_conditions_codec);
      if (Combiner != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Combiner);
      }
      if (enabled_ != null) {
        size += _single_enabled_codec.CalculateSizeWithTag(Enabled);
      }
      if (validity_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Validity);
      }
      size += notificationChannels_.CalculateSize(_repeated_notificationChannels_codec);
      if (creationRecord_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(CreationRecord);
      }
      if (mutationRecord_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(MutationRecord);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(AlertPolicy other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.DisplayName.Length != 0) {
        DisplayName = other.DisplayName;
      }
      if (other.documentation_ != null) {
        if (documentation_ == null) {
          Documentation = new global::Google.Cloud.Monitoring.V3.AlertPolicy.Types.Documentation();
        }
        Documentation.MergeFrom(other.Documentation);
      }
      userLabels_.Add(other.userLabels_);
      conditions_.Add(other.conditions_);
      if (other.Combiner != 0) {
        Combiner = other.Combiner;
      }
      if (other.enabled_ != null) {
        if (enabled_ == null || other.Enabled != false) {
          Enabled = other.Enabled;
        }
      }
      if (other.validity_ != null) {
        if (validity_ == null) {
          Validity = new global::Google.Rpc.Status();
        }
        Validity.MergeFrom(other.Validity);
      }
      notificationChannels_.Add(other.notificationChannels_);
      if (other.creationRecord_ != null) {
        if (creationRecord_ == null) {
          CreationRecord = new global::Google.Cloud.Monitoring.V3.MutationRecord();
        }
        CreationRecord.MergeFrom(other.CreationRecord);
      }
      if (other.mutationRecord_ != null) {
        if (mutationRecord_ == null) {
          MutationRecord = new global::Google.Cloud.Monitoring.V3.MutationRecord();
        }
        MutationRecord.MergeFrom(other.MutationRecord);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            DisplayName = input.ReadString();
            break;
          }
          case 48: {
            Combiner = (global::Google.Cloud.Monitoring.V3.AlertPolicy.Types.ConditionCombinerType) input.ReadEnum();
            break;
          }
          case 82: {
            if (creationRecord_ == null) {
              CreationRecord = new global::Google.Cloud.Monitoring.V3.MutationRecord();
            }
            input.ReadMessage(CreationRecord);
            break;
          }
          case 90: {
            if (mutationRecord_ == null) {
              MutationRecord = new global::Google.Cloud.Monitoring.V3.MutationRecord();
            }
            input.ReadMessage(MutationRecord);
            break;
          }
          case 98: {
            conditions_.AddEntriesFrom(input, _repeated_conditions_codec);
            break;
          }
          case 106: {
            if (documentation_ == null) {
              Documentation = new global::Google.Cloud.Monitoring.V3.AlertPolicy.Types.Documentation();
            }
            input.ReadMessage(Documentation);
            break;
          }
          case 114: {
            notificationChannels_.AddEntriesFrom(input, _repeated_notificationChannels_codec);
            break;
          }
          case 130: {
            userLabels_.AddEntriesFrom(input, _map_userLabels_codec);
            break;
          }
          case 138: {
            bool? value = _single_enabled_codec.Read(input);
            if (enabled_ == null || value != false) {
              Enabled = value;
            }
            break;
          }
          case 146: {
            if (validity_ == null) {
              Validity = new global::Google.Rpc.Status();
            }
            input.ReadMessage(Validity);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the AlertPolicy message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Operators for combining conditions.
      /// </summary>
      public enum ConditionCombinerType {
        /// <summary>
        /// An unspecified combiner.
        /// </summary>
        [pbr::OriginalName("COMBINE_UNSPECIFIED")] CombineUnspecified = 0,
        /// <summary>
        /// Combine conditions using the logical `AND` operator. An
        /// incident is created only if all conditions are met
        /// simultaneously. This combiner is satisfied if all conditions are
        /// met, even if they are met on completely different resources.
        /// </summary>
        [pbr::OriginalName("AND")] And = 1,
        /// <summary>
        /// Combine conditions using the logical `OR` operator. An incident
        /// is created if any of the listed conditions is met.
        /// </summary>
        [pbr::OriginalName("OR")] Or = 2,
        /// <summary>
        /// Combine conditions using logical `AND` operator, but unlike the regular
        /// `AND` option, an incident is created only if all conditions are met
        /// simultaneously on at least one resource.
        /// </summary>
        [pbr::OriginalName("AND_WITH_MATCHING_RESOURCE")] AndWithMatchingResource = 3,
      }

      /// <summary>
      /// A content string and a MIME type that describes the content string's
      /// format.
      /// </summary>
      public sealed partial class Documentation : pb::IMessage<Documentation> {
        private static readonly pb::MessageParser<Documentation> _parser = new pb::MessageParser<Documentation>(() => new Documentation());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Documentation> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Cloud.Monitoring.V3.AlertPolicy.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Documentation() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Documentation(Documentation other) : this() {
          content_ = other.content_;
          mimeType_ = other.mimeType_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Documentation Clone() {
          return new Documentation(this);
        }

        /// <summary>Field number for the "content" field.</summary>
        public const int ContentFieldNumber = 1;
        private string content_ = "";
        /// <summary>
        /// The text of the documentation, interpreted according to `mime_type`.
        /// The content may not exceed 8,192 Unicode characters and may not exceed
        /// more than 10,240 bytes when encoded in UTF-8 format, whichever is
        /// smaller.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Content {
          get { return content_; }
          set {
            content_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "mime_type" field.</summary>
        public const int MimeTypeFieldNumber = 2;
        private string mimeType_ = "";
        /// <summary>
        /// The format of the `content` field. Presently, only the value
        /// `"text/markdown"` is supported. See
        /// [Markdown](https://en.wikipedia.org/wiki/Markdown) for more information.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string MimeType {
          get { return mimeType_; }
          set {
            mimeType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Documentation);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Documentation other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Content != other.Content) return false;
          if (MimeType != other.MimeType) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Content.Length != 0) hash ^= Content.GetHashCode();
          if (MimeType.Length != 0) hash ^= MimeType.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (Content.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Content);
          }
          if (MimeType.Length != 0) {
            output.WriteRawTag(18);
            output.WriteString(MimeType);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Content.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Content);
          }
          if (MimeType.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(MimeType);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Documentation other) {
          if (other == null) {
            return;
          }
          if (other.Content.Length != 0) {
            Content = other.Content;
          }
          if (other.MimeType.Length != 0) {
            MimeType = other.MimeType;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                Content = input.ReadString();
                break;
              }
              case 18: {
                MimeType = input.ReadString();
                break;
              }
            }
          }
        }

      }

      /// <summary>
      /// A condition is a true/false test that determines when an alerting policy
      /// should open an incident. If a condition evaluates to true, it signifies
      /// that something is wrong.
      /// </summary>
      public sealed partial class Condition : pb::IMessage<Condition> {
        private static readonly pb::MessageParser<Condition> _parser = new pb::MessageParser<Condition>(() => new Condition());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Condition> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Cloud.Monitoring.V3.AlertPolicy.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Condition() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Condition(Condition other) : this() {
          name_ = other.name_;
          displayName_ = other.displayName_;
          switch (other.ConditionCase) {
            case ConditionOneofCase.ConditionThreshold:
              ConditionThreshold = other.ConditionThreshold.Clone();
              break;
            case ConditionOneofCase.ConditionAbsent:
              ConditionAbsent = other.ConditionAbsent.Clone();
              break;
          }

          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Condition Clone() {
          return new Condition(this);
        }

        /// <summary>Field number for the "name" field.</summary>
        public const int NameFieldNumber = 12;
        private string name_ = "";
        /// <summary>
        /// Required if the condition exists. The unique resource name for this
        /// condition. Its syntax is:
        ///
        ///     projects/[PROJECT_ID]/alertPolicies/[POLICY_ID]/conditions/[CONDITION_ID]
        ///
        /// `[CONDITION_ID]` is assigned by Stackdriver Monitoring when the
        /// condition is created as part of a new or updated alerting policy.
        ///
        /// When calling the
        /// [alertPolicies.create][google.monitoring.v3.AlertPolicyService.CreateAlertPolicy]
        /// method, do not include the `name` field in the conditions of the
        /// requested alerting policy. Stackdriver Monitoring creates the
        /// condition identifiers and includes them in the new policy.
        ///
        /// When calling the
        /// [alertPolicies.update][google.monitoring.v3.AlertPolicyService.UpdateAlertPolicy]
        /// method to update a policy, including a condition `name` causes the
        /// existing condition to be updated. Conditions without names are added to
        /// the updated policy. Existing conditions are deleted if they are not
        /// updated.
        ///
        /// Best practice is to preserve `[CONDITION_ID]` if you make only small
        /// changes, such as those to condition thresholds, durations, or trigger
        /// values.  Otherwise, treat the change as a new condition and let the
        /// existing condition be deleted.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Name {
          get { return name_; }
          set {
            name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "display_name" field.</summary>
        public const int DisplayNameFieldNumber = 6;
        private string displayName_ = "";
        /// <summary>
        /// A short name or phrase used to identify the condition in dashboards,
        /// notifications, and incidents. To avoid confusion, don't use the same
        /// display name for multiple conditions in the same policy.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string DisplayName {
          get { return displayName_; }
          set {
            displayName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "condition_threshold" field.</summary>
        public const int ConditionThresholdFieldNumber = 1;
        /// <summary>
        /// A condition that compares a time series against a threshold.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Cloud.Monitoring.V3.AlertPolicy.Types.Condition.Types.MetricThreshold ConditionThreshold {
          get { return conditionCase_ == ConditionOneofCase.ConditionThreshold ? (global::Google.Cloud.Monitoring.V3.AlertPolicy.Types.Condition.Types.MetricThreshold) condition_ : null; }
          set {
            condition_ = value;
            conditionCase_ = value == null ? ConditionOneofCase.None : ConditionOneofCase.ConditionThreshold;
          }
        }

        /// <summary>Field number for the "condition_absent" field.</summary>
        public const int ConditionAbsentFieldNumber = 2;
        /// <summary>
        /// A condition that checks that a time series continues to
        /// receive new data points.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Cloud.Monitoring.V3.AlertPolicy.Types.Condition.Types.MetricAbsence ConditionAbsent {
          get { return conditionCase_ == ConditionOneofCase.ConditionAbsent ? (global::Google.Cloud.Monitoring.V3.AlertPolicy.Types.Condition.Types.MetricAbsence) condition_ : null; }
          set {
            condition_ = value;
            conditionCase_ = value == null ? ConditionOneofCase.None : ConditionOneofCase.ConditionAbsent;
          }
        }

        private object condition_;
        /// <summary>Enum of possible cases for the "condition" oneof.</summary>
        public enum ConditionOneofCase {
          None = 0,
          ConditionThreshold = 1,
          ConditionAbsent = 2,
        }
        private ConditionOneofCase conditionCase_ = ConditionOneofCase.None;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ConditionOneofCase ConditionCase {
          get { return conditionCase_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearCondition() {
          conditionCase_ = ConditionOneofCase.None;
          condition_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Condition);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Condition other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Name != other.Name) return false;
          if (DisplayName != other.DisplayName) return false;
          if (!object.Equals(ConditionThreshold, other.ConditionThreshold)) return false;
          if (!object.Equals(ConditionAbsent, other.ConditionAbsent)) return false;
          if (ConditionCase != other.ConditionCase) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Name.Length != 0) hash ^= Name.GetHashCode();
          if (DisplayName.Length != 0) hash ^= DisplayName.GetHashCode();
          if (conditionCase_ == ConditionOneofCase.ConditionThreshold) hash ^= ConditionThreshold.GetHashCode();
          if (conditionCase_ == ConditionOneofCase.ConditionAbsent) hash ^= ConditionAbsent.GetHashCode();
          hash ^= (int) conditionCase_;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (conditionCase_ == ConditionOneofCase.ConditionThreshold) {
            output.WriteRawTag(10);
            output.WriteMessage(ConditionThreshold);
          }
          if (conditionCase_ == ConditionOneofCase.ConditionAbsent) {
            output.WriteRawTag(18);
            output.WriteMessage(ConditionAbsent);
          }
          if (DisplayName.Length != 0) {
            output.WriteRawTag(50);
            output.WriteString(DisplayName);
          }
          if (Name.Length != 0) {
            output.WriteRawTag(98);
            output.WriteString(Name);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Name.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
          }
          if (DisplayName.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(DisplayName);
          }
          if (conditionCase_ == ConditionOneofCase.ConditionThreshold) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(ConditionThreshold);
          }
          if (conditionCase_ == ConditionOneofCase.ConditionAbsent) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(ConditionAbsent);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Condition other) {
          if (other == null) {
            return;
          }
          if (other.Name.Length != 0) {
            Name = other.Name;
          }
          if (other.DisplayName.Length != 0) {
            DisplayName = other.DisplayName;
          }
          switch (other.ConditionCase) {
            case ConditionOneofCase.ConditionThreshold:
              if (ConditionThreshold == null) {
                ConditionThreshold = new global::Google.Cloud.Monitoring.V3.AlertPolicy.Types.Condition.Types.MetricThreshold();
              }
              ConditionThreshold.MergeFrom(other.ConditionThreshold);
              break;
            case ConditionOneofCase.ConditionAbsent:
              if (ConditionAbsent == null) {
                ConditionAbsent = new global::Google.Cloud.Monitoring.V3.AlertPolicy.Types.Condition.Types.MetricAbsence();
              }
              ConditionAbsent.MergeFrom(other.ConditionAbsent);
              break;
          }

          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                global::Google.Cloud.Monitoring.V3.AlertPolicy.Types.Condition.Types.MetricThreshold subBuilder = new global::Google.Cloud.Monitoring.V3.AlertPolicy.Types.Condition.Types.MetricThreshold();
                if (conditionCase_ == ConditionOneofCase.ConditionThreshold) {
                  subBuilder.MergeFrom(ConditionThreshold);
                }
                input.ReadMessage(subBuilder);
                ConditionThreshold = subBuilder;
                break;
              }
              case 18: {
                global::Google.Cloud.Monitoring.V3.AlertPolicy.Types.Condition.Types.MetricAbsence subBuilder = new global::Google.Cloud.Monitoring.V3.AlertPolicy.Types.Condition.Types.MetricAbsence();
                if (conditionCase_ == ConditionOneofCase.ConditionAbsent) {
                  subBuilder.MergeFrom(ConditionAbsent);
                }
                input.ReadMessage(subBuilder);
                ConditionAbsent = subBuilder;
                break;
              }
              case 50: {
                DisplayName = input.ReadString();
                break;
              }
              case 98: {
                Name = input.ReadString();
                break;
              }
            }
          }
        }

        #region Nested types
        /// <summary>Container for nested types declared in the Condition message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types {
          /// <summary>
          /// Specifies how many time series must fail a predicate to trigger a
          /// condition. If not specified, then a `{count: 1}` trigger is used.
          /// </summary>
          public sealed partial class Trigger : pb::IMessage<Trigger> {
            private static readonly pb::MessageParser<Trigger> _parser = new pb::MessageParser<Trigger>(() => new Trigger());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pb::MessageParser<Trigger> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Google.Cloud.Monitoring.V3.AlertPolicy.Types.Condition.Descriptor.NestedTypes[0]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public Trigger() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public Trigger(Trigger other) : this() {
              switch (other.TypeCase) {
                case TypeOneofCase.Count:
                  Count = other.Count;
                  break;
                case TypeOneofCase.Percent:
                  Percent = other.Percent;
                  break;
              }

              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public Trigger Clone() {
              return new Trigger(this);
            }

            /// <summary>Field number for the "count" field.</summary>
            public const int CountFieldNumber = 1;
            /// <summary>
            /// The absolute number of time series that must fail
            /// the predicate for the condition to be triggered.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public int Count {
              get { return typeCase_ == TypeOneofCase.Count ? (int) type_ : 0; }
              set {
                type_ = value;
                typeCase_ = TypeOneofCase.Count;
              }
            }

            /// <summary>Field number for the "percent" field.</summary>
            public const int PercentFieldNumber = 2;
            /// <summary>
            /// The percentage of time series that must fail the
            /// predicate for the condition to be triggered.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public double Percent {
              get { return typeCase_ == TypeOneofCase.Percent ? (double) type_ : 0D; }
              set {
                type_ = value;
                typeCase_ = TypeOneofCase.Percent;
              }
            }

            private object type_;
            /// <summary>Enum of possible cases for the "type" oneof.</summary>
            public enum TypeOneofCase {
              None = 0,
              Count = 1,
              Percent = 2,
            }
            private TypeOneofCase typeCase_ = TypeOneofCase.None;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public TypeOneofCase TypeCase {
              get { return typeCase_; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void ClearType() {
              typeCase_ = TypeOneofCase.None;
              type_ = null;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override bool Equals(object other) {
              return Equals(other as Trigger);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool Equals(Trigger other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (Count != other.Count) return false;
              if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Percent, other.Percent)) return false;
              if (TypeCase != other.TypeCase) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override int GetHashCode() {
              int hash = 1;
              if (typeCase_ == TypeOneofCase.Count) hash ^= Count.GetHashCode();
              if (typeCase_ == TypeOneofCase.Percent) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Percent);
              hash ^= (int) typeCase_;
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void WriteTo(pb::CodedOutputStream output) {
              if (typeCase_ == TypeOneofCase.Count) {
                output.WriteRawTag(8);
                output.WriteInt32(Count);
              }
              if (typeCase_ == TypeOneofCase.Percent) {
                output.WriteRawTag(17);
                output.WriteDouble(Percent);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public int CalculateSize() {
              int size = 0;
              if (typeCase_ == TypeOneofCase.Count) {
                size += 1 + pb::CodedOutputStream.ComputeInt32Size(Count);
              }
              if (typeCase_ == TypeOneofCase.Percent) {
                size += 1 + 8;
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(Trigger other) {
              if (other == null) {
                return;
              }
              switch (other.TypeCase) {
                case TypeOneofCase.Count:
                  Count = other.Count;
                  break;
                case TypeOneofCase.Percent:
                  Percent = other.Percent;
                  break;
              }

              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(pb::CodedInputStream input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 8: {
                    Count = input.ReadInt32();
                    break;
                  }
                  case 17: {
                    Percent = input.ReadDouble();
                    break;
                  }
                }
              }
            }

          }

          /// <summary>
          /// A condition type that compares a collection of time series
          /// against a threshold.
          /// </summary>
          public sealed partial class MetricThreshold : pb::IMessage<MetricThreshold> {
            private static readonly pb::MessageParser<MetricThreshold> _parser = new pb::MessageParser<MetricThreshold>(() => new MetricThreshold());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pb::MessageParser<MetricThreshold> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Google.Cloud.Monitoring.V3.AlertPolicy.Types.Condition.Descriptor.NestedTypes[1]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public MetricThreshold() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public MetricThreshold(MetricThreshold other) : this() {
              filter_ = other.filter_;
              aggregations_ = other.aggregations_.Clone();
              denominatorFilter_ = other.denominatorFilter_;
              denominatorAggregations_ = other.denominatorAggregations_.Clone();
              comparison_ = other.comparison_;
              thresholdValue_ = other.thresholdValue_;
              duration_ = other.duration_ != null ? other.duration_.Clone() : null;
              trigger_ = other.trigger_ != null ? other.trigger_.Clone() : null;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public MetricThreshold Clone() {
              return new MetricThreshold(this);
            }

            /// <summary>Field number for the "filter" field.</summary>
            public const int FilterFieldNumber = 2;
            private string filter_ = "";
            /// <summary>
            /// A [filter](/monitoring/api/v3/filters) that
            /// identifies which time series should be compared with the threshold.
            ///
            /// The filter is similar to the one that is specified in the
            /// [`ListTimeSeries`
            /// request](/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) (that
            /// call is useful to verify the time series that will be retrieved /
            /// processed) and must specify the metric type and optionally may contain
            /// restrictions on resource type, resource labels, and metric labels.
            /// This field may not exceed 2048 Unicode characters in length.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public string Filter {
              get { return filter_; }
              set {
                filter_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
              }
            }

            /// <summary>Field number for the "aggregations" field.</summary>
            public const int AggregationsFieldNumber = 8;
            private static readonly pb::FieldCodec<global::Google.Cloud.Monitoring.V3.Aggregation> _repeated_aggregations_codec
                = pb::FieldCodec.ForMessage(66, global::Google.Cloud.Monitoring.V3.Aggregation.Parser);
            private readonly pbc::RepeatedField<global::Google.Cloud.Monitoring.V3.Aggregation> aggregations_ = new pbc::RepeatedField<global::Google.Cloud.Monitoring.V3.Aggregation>();
            /// <summary>
            /// Specifies the alignment of data points in individual time series as
            /// well as how to combine the retrieved time series together (such as
            /// when aggregating multiple streams on each resource to a single
            /// stream for each resource or when aggregating streams across all
            /// members of a group of resrouces). Multiple aggregations
            /// are applied in the order specified.
            ///
            /// This field is similar to the one in the [`ListTimeSeries`
            /// request](/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list). It
            /// is advisable to use the `ListTimeSeries` method when debugging this
            /// field.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public pbc::RepeatedField<global::Google.Cloud.Monitoring.V3.Aggregation> Aggregations {
              get { return aggregations_; }
            }

            /// <summary>Field number for the "denominator_filter" field.</summary>
            public const int DenominatorFilterFieldNumber = 9;
            private string denominatorFilter_ = "";
            /// <summary>
            /// A [filter](/monitoring/api/v3/filters) that identifies a time
            /// series that should be used as the denominator of a ratio that will be
            /// compared with the threshold. If a `denominator_filter` is specified,
            /// the time series specified by the `filter` field will be used as the
            /// numerator.
            ///
            /// The filter must specify the metric type and optionally may contain
            /// restrictions on resource type, resource labels, and metric labels.
            /// This field may not exceed 2048 Unicode characters in length.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public string DenominatorFilter {
              get { return denominatorFilter_; }
              set {
                denominatorFilter_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
              }
            }

            /// <summary>Field number for the "denominator_aggregations" field.</summary>
            public const int DenominatorAggregationsFieldNumber = 10;
            private static readonly pb::FieldCodec<global::Google.Cloud.Monitoring.V3.Aggregation> _repeated_denominatorAggregations_codec
                = pb::FieldCodec.ForMessage(82, global::Google.Cloud.Monitoring.V3.Aggregation.Parser);
            private readonly pbc::RepeatedField<global::Google.Cloud.Monitoring.V3.Aggregation> denominatorAggregations_ = new pbc::RepeatedField<global::Google.Cloud.Monitoring.V3.Aggregation>();
            /// <summary>
            /// Specifies the alignment of data points in individual time series
            /// selected by `denominatorFilter` as
            /// well as how to combine the retrieved time series together (such as
            /// when aggregating multiple streams on each resource to a single
            /// stream for each resource or when aggregating streams across all
            /// members of a group of resources).
            ///
            /// When computing ratios, the `aggregations` and
            /// `denominator_aggregations` fields must use the same alignment period
            /// and produce time series that have the same periodicity and labels.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public pbc::RepeatedField<global::Google.Cloud.Monitoring.V3.Aggregation> DenominatorAggregations {
              get { return denominatorAggregations_; }
            }

            /// <summary>Field number for the "comparison" field.</summary>
            public const int ComparisonFieldNumber = 4;
            private global::Google.Cloud.Monitoring.V3.ComparisonType comparison_ = 0;
            /// <summary>
            /// The comparison to apply between the time series (indicated by `filter`
            /// and `aggregation`) and the threshold (indicated by `threshold_value`).
            /// The comparison is applied on each time series, with the time series
            /// on the left-hand side and the threshold on the right-hand side.
            ///
            /// Only `COMPARISON_LT` and `COMPARISON_GT` are supported currently.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public global::Google.Cloud.Monitoring.V3.ComparisonType Comparison {
              get { return comparison_; }
              set {
                comparison_ = value;
              }
            }

            /// <summary>Field number for the "threshold_value" field.</summary>
            public const int ThresholdValueFieldNumber = 5;
            private double thresholdValue_;
            /// <summary>
            /// A value against which to compare the time series.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public double ThresholdValue {
              get { return thresholdValue_; }
              set {
                thresholdValue_ = value;
              }
            }

            /// <summary>Field number for the "duration" field.</summary>
            public const int DurationFieldNumber = 6;
            private global::Google.Protobuf.WellKnownTypes.Duration duration_;
            /// <summary>
            /// The amount of time that a time series must violate the
            /// threshold to be considered failing. Currently, only values
            /// that are a multiple of a minute--e.g., 0, 60, 120, or 300
            /// seconds--are supported. If an invalid value is given, an
            /// error will be returned. When choosing a duration, it is useful to
            /// keep in mind the frequency of the underlying time series data
            /// (which may also be affected by any alignments specified in the
            /// `aggregations` field); a good duration is long enough so that a single
            /// outlier does not generate spurious alerts, but short enough that
            /// unhealthy states are detected and alerted on quickly.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public global::Google.Protobuf.WellKnownTypes.Duration Duration {
              get { return duration_; }
              set {
                duration_ = value;
              }
            }

            /// <summary>Field number for the "trigger" field.</summary>
            public const int TriggerFieldNumber = 7;
            private global::Google.Cloud.Monitoring.V3.AlertPolicy.Types.Condition.Types.Trigger trigger_;
            /// <summary>
            /// The number/percent of time series for which the comparison must hold
            /// in order for the condition to trigger. If unspecified, then the
            /// condition will trigger if the comparison is true for any of the
            /// time series that have been identified by `filter` and `aggregations`,
            /// or by the ratio, if `denominator_filter` and `denominator_aggregations`
            /// are specified.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public global::Google.Cloud.Monitoring.V3.AlertPolicy.Types.Condition.Types.Trigger Trigger {
              get { return trigger_; }
              set {
                trigger_ = value;
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override bool Equals(object other) {
              return Equals(other as MetricThreshold);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool Equals(MetricThreshold other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (Filter != other.Filter) return false;
              if(!aggregations_.Equals(other.aggregations_)) return false;
              if (DenominatorFilter != other.DenominatorFilter) return false;
              if(!denominatorAggregations_.Equals(other.denominatorAggregations_)) return false;
              if (Comparison != other.Comparison) return false;
              if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(ThresholdValue, other.ThresholdValue)) return false;
              if (!object.Equals(Duration, other.Duration)) return false;
              if (!object.Equals(Trigger, other.Trigger)) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override int GetHashCode() {
              int hash = 1;
              if (Filter.Length != 0) hash ^= Filter.GetHashCode();
              hash ^= aggregations_.GetHashCode();
              if (DenominatorFilter.Length != 0) hash ^= DenominatorFilter.GetHashCode();
              hash ^= denominatorAggregations_.GetHashCode();
              if (Comparison != 0) hash ^= Comparison.GetHashCode();
              if (ThresholdValue != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(ThresholdValue);
              if (duration_ != null) hash ^= Duration.GetHashCode();
              if (trigger_ != null) hash ^= Trigger.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void WriteTo(pb::CodedOutputStream output) {
              if (Filter.Length != 0) {
                output.WriteRawTag(18);
                output.WriteString(Filter);
              }
              if (Comparison != 0) {
                output.WriteRawTag(32);
                output.WriteEnum((int) Comparison);
              }
              if (ThresholdValue != 0D) {
                output.WriteRawTag(41);
                output.WriteDouble(ThresholdValue);
              }
              if (duration_ != null) {
                output.WriteRawTag(50);
                output.WriteMessage(Duration);
              }
              if (trigger_ != null) {
                output.WriteRawTag(58);
                output.WriteMessage(Trigger);
              }
              aggregations_.WriteTo(output, _repeated_aggregations_codec);
              if (DenominatorFilter.Length != 0) {
                output.WriteRawTag(74);
                output.WriteString(DenominatorFilter);
              }
              denominatorAggregations_.WriteTo(output, _repeated_denominatorAggregations_codec);
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public int CalculateSize() {
              int size = 0;
              if (Filter.Length != 0) {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(Filter);
              }
              size += aggregations_.CalculateSize(_repeated_aggregations_codec);
              if (DenominatorFilter.Length != 0) {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(DenominatorFilter);
              }
              size += denominatorAggregations_.CalculateSize(_repeated_denominatorAggregations_codec);
              if (Comparison != 0) {
                size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Comparison);
              }
              if (ThresholdValue != 0D) {
                size += 1 + 8;
              }
              if (duration_ != null) {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Duration);
              }
              if (trigger_ != null) {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Trigger);
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(MetricThreshold other) {
              if (other == null) {
                return;
              }
              if (other.Filter.Length != 0) {
                Filter = other.Filter;
              }
              aggregations_.Add(other.aggregations_);
              if (other.DenominatorFilter.Length != 0) {
                DenominatorFilter = other.DenominatorFilter;
              }
              denominatorAggregations_.Add(other.denominatorAggregations_);
              if (other.Comparison != 0) {
                Comparison = other.Comparison;
              }
              if (other.ThresholdValue != 0D) {
                ThresholdValue = other.ThresholdValue;
              }
              if (other.duration_ != null) {
                if (duration_ == null) {
                  Duration = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                Duration.MergeFrom(other.Duration);
              }
              if (other.trigger_ != null) {
                if (trigger_ == null) {
                  Trigger = new global::Google.Cloud.Monitoring.V3.AlertPolicy.Types.Condition.Types.Trigger();
                }
                Trigger.MergeFrom(other.Trigger);
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(pb::CodedInputStream input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 18: {
                    Filter = input.ReadString();
                    break;
                  }
                  case 32: {
                    Comparison = (global::Google.Cloud.Monitoring.V3.ComparisonType) input.ReadEnum();
                    break;
                  }
                  case 41: {
                    ThresholdValue = input.ReadDouble();
                    break;
                  }
                  case 50: {
                    if (duration_ == null) {
                      Duration = new global::Google.Protobuf.WellKnownTypes.Duration();
                    }
                    input.ReadMessage(Duration);
                    break;
                  }
                  case 58: {
                    if (trigger_ == null) {
                      Trigger = new global::Google.Cloud.Monitoring.V3.AlertPolicy.Types.Condition.Types.Trigger();
                    }
                    input.ReadMessage(Trigger);
                    break;
                  }
                  case 66: {
                    aggregations_.AddEntriesFrom(input, _repeated_aggregations_codec);
                    break;
                  }
                  case 74: {
                    DenominatorFilter = input.ReadString();
                    break;
                  }
                  case 82: {
                    denominatorAggregations_.AddEntriesFrom(input, _repeated_denominatorAggregations_codec);
                    break;
                  }
                }
              }
            }

          }

          /// <summary>
          /// A condition type that checks that monitored resources
          /// are reporting data. The configuration defines a metric and
          /// a set of monitored resources. The predicate is considered in violation
          /// when a time series for the specified metric of a monitored
          /// resource does not include any data in the specified `duration`.
          /// </summary>
          public sealed partial class MetricAbsence : pb::IMessage<MetricAbsence> {
            private static readonly pb::MessageParser<MetricAbsence> _parser = new pb::MessageParser<MetricAbsence>(() => new MetricAbsence());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pb::MessageParser<MetricAbsence> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Google.Cloud.Monitoring.V3.AlertPolicy.Types.Condition.Descriptor.NestedTypes[2]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public MetricAbsence() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public MetricAbsence(MetricAbsence other) : this() {
              filter_ = other.filter_;
              aggregations_ = other.aggregations_.Clone();
              duration_ = other.duration_ != null ? other.duration_.Clone() : null;
              trigger_ = other.trigger_ != null ? other.trigger_.Clone() : null;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public MetricAbsence Clone() {
              return new MetricAbsence(this);
            }

            /// <summary>Field number for the "filter" field.</summary>
            public const int FilterFieldNumber = 1;
            private string filter_ = "";
            /// <summary>
            /// A [filter](/monitoring/api/v3/filters) that
            /// identifies which time series should be compared with the threshold.
            ///
            /// The filter is similar to the one that is specified in the
            /// [`ListTimeSeries`
            /// request](/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) (that
            /// call is useful to verify the time series that will be retrieved /
            /// processed) and must specify the metric type and optionally may contain
            /// restrictions on resource type, resource labels, and metric labels.
            /// This field may not exceed 2048 Unicode characters in length.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public string Filter {
              get { return filter_; }
              set {
                filter_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
              }
            }

            /// <summary>Field number for the "aggregations" field.</summary>
            public const int AggregationsFieldNumber = 5;
            private static readonly pb::FieldCodec<global::Google.Cloud.Monitoring.V3.Aggregation> _repeated_aggregations_codec
                = pb::FieldCodec.ForMessage(42, global::Google.Cloud.Monitoring.V3.Aggregation.Parser);
            private readonly pbc::RepeatedField<global::Google.Cloud.Monitoring.V3.Aggregation> aggregations_ = new pbc::RepeatedField<global::Google.Cloud.Monitoring.V3.Aggregation>();
            /// <summary>
            /// Specifies the alignment of data points in individual time series as
            /// well as how to combine the retrieved time series together (such as
            /// when aggregating multiple streams on each resource to a single
            /// stream for each resource or when aggregating streams across all
            /// members of a group of resrouces). Multiple aggregations
            /// are applied in the order specified.
            ///
            /// This field is similar to the one in the [`ListTimeSeries`
            /// request](/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list). It
            /// is advisable to use the `ListTimeSeries` method when debugging this
            /// field.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public pbc::RepeatedField<global::Google.Cloud.Monitoring.V3.Aggregation> Aggregations {
              get { return aggregations_; }
            }

            /// <summary>Field number for the "duration" field.</summary>
            public const int DurationFieldNumber = 2;
            private global::Google.Protobuf.WellKnownTypes.Duration duration_;
            /// <summary>
            /// The amount of time that a time series must fail to report new
            /// data to be considered failing. Currently, only values that
            /// are a multiple of a minute--e.g.  60, 120, or 300
            /// seconds--are supported. If an invalid value is given, an
            /// error will be returned. The `Duration.nanos` field is
            /// ignored.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public global::Google.Protobuf.WellKnownTypes.Duration Duration {
              get { return duration_; }
              set {
                duration_ = value;
              }
            }

            /// <summary>Field number for the "trigger" field.</summary>
            public const int TriggerFieldNumber = 3;
            private global::Google.Cloud.Monitoring.V3.AlertPolicy.Types.Condition.Types.Trigger trigger_;
            /// <summary>
            /// The number/percent of time series for which the comparison must hold
            /// in order for the condition to trigger. If unspecified, then the
            /// condition will trigger if the comparison is true for any of the
            /// time series that have been identified by `filter` and `aggregations`.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public global::Google.Cloud.Monitoring.V3.AlertPolicy.Types.Condition.Types.Trigger Trigger {
              get { return trigger_; }
              set {
                trigger_ = value;
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override bool Equals(object other) {
              return Equals(other as MetricAbsence);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool Equals(MetricAbsence other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (Filter != other.Filter) return false;
              if(!aggregations_.Equals(other.aggregations_)) return false;
              if (!object.Equals(Duration, other.Duration)) return false;
              if (!object.Equals(Trigger, other.Trigger)) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override int GetHashCode() {
              int hash = 1;
              if (Filter.Length != 0) hash ^= Filter.GetHashCode();
              hash ^= aggregations_.GetHashCode();
              if (duration_ != null) hash ^= Duration.GetHashCode();
              if (trigger_ != null) hash ^= Trigger.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void WriteTo(pb::CodedOutputStream output) {
              if (Filter.Length != 0) {
                output.WriteRawTag(10);
                output.WriteString(Filter);
              }
              if (duration_ != null) {
                output.WriteRawTag(18);
                output.WriteMessage(Duration);
              }
              if (trigger_ != null) {
                output.WriteRawTag(26);
                output.WriteMessage(Trigger);
              }
              aggregations_.WriteTo(output, _repeated_aggregations_codec);
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public int CalculateSize() {
              int size = 0;
              if (Filter.Length != 0) {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(Filter);
              }
              size += aggregations_.CalculateSize(_repeated_aggregations_codec);
              if (duration_ != null) {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Duration);
              }
              if (trigger_ != null) {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Trigger);
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(MetricAbsence other) {
              if (other == null) {
                return;
              }
              if (other.Filter.Length != 0) {
                Filter = other.Filter;
              }
              aggregations_.Add(other.aggregations_);
              if (other.duration_ != null) {
                if (duration_ == null) {
                  Duration = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                Duration.MergeFrom(other.Duration);
              }
              if (other.trigger_ != null) {
                if (trigger_ == null) {
                  Trigger = new global::Google.Cloud.Monitoring.V3.AlertPolicy.Types.Condition.Types.Trigger();
                }
                Trigger.MergeFrom(other.Trigger);
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(pb::CodedInputStream input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 10: {
                    Filter = input.ReadString();
                    break;
                  }
                  case 18: {
                    if (duration_ == null) {
                      Duration = new global::Google.Protobuf.WellKnownTypes.Duration();
                    }
                    input.ReadMessage(Duration);
                    break;
                  }
                  case 26: {
                    if (trigger_ == null) {
                      Trigger = new global::Google.Cloud.Monitoring.V3.AlertPolicy.Types.Condition.Types.Trigger();
                    }
                    input.ReadMessage(Trigger);
                    break;
                  }
                  case 42: {
                    aggregations_.AddEntriesFrom(input, _repeated_aggregations_codec);
                    break;
                  }
                }
              }
            }

          }

        }
        #endregion

      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
