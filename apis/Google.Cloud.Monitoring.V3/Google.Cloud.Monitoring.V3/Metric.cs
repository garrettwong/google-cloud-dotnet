// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: google/monitoring/v3/metric.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Google.Cloud.Monitoring.V3 {

  /// <summary>Holder for reflection information generated from google/monitoring/v3/metric.proto</summary>
  public static partial class MetricReflection {

    #region Descriptor
    /// <summary>File descriptor for google/monitoring/v3/metric.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static MetricReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CiFnb29nbGUvbW9uaXRvcmluZy92My9tZXRyaWMucHJvdG8SFGdvb2dsZS5t",
            "b25pdG9yaW5nLnYzGh1nb29nbGUvYXBpL2Rpc3RyaWJ1dGlvbi5wcm90bxoW",
            "Z29vZ2xlL2FwaS9sYWJlbC5wcm90bxoXZ29vZ2xlL2FwaS9tZXRyaWMucHJv",
            "dG8aI2dvb2dsZS9hcGkvbW9uaXRvcmVkX3Jlc291cmNlLnByb3RvGiFnb29n",
            "bGUvbW9uaXRvcmluZy92My9jb21tb24ucHJvdG8ibgoFUG9pbnQSNAoIaW50",
            "ZXJ2YWwYASABKAsyIi5nb29nbGUubW9uaXRvcmluZy52My5UaW1lSW50ZXJ2",
            "YWwSLwoFdmFsdWUYAiABKAsyIC5nb29nbGUubW9uaXRvcmluZy52My5UeXBl",
            "ZFZhbHVlIsECCgpUaW1lU2VyaWVzEiIKBm1ldHJpYxgBIAEoCzISLmdvb2ds",
            "ZS5hcGkuTWV0cmljEi8KCHJlc291cmNlGAIgASgLMh0uZ29vZ2xlLmFwaS5N",
            "b25pdG9yZWRSZXNvdXJjZRI3CghtZXRhZGF0YRgHIAEoCzIlLmdvb2dsZS5h",
            "cGkuTW9uaXRvcmVkUmVzb3VyY2VNZXRhZGF0YRI8CgttZXRyaWNfa2luZBgD",
            "IAEoDjInLmdvb2dsZS5hcGkuTWV0cmljRGVzY3JpcHRvci5NZXRyaWNLaW5k",
            "EjoKCnZhbHVlX3R5cGUYBCABKA4yJi5nb29nbGUuYXBpLk1ldHJpY0Rlc2Ny",
            "aXB0b3IuVmFsdWVUeXBlEisKBnBvaW50cxgFIAMoCzIbLmdvb2dsZS5tb25p",
            "dG9yaW5nLnYzLlBvaW50QqMBChhjb20uZ29vZ2xlLm1vbml0b3JpbmcudjNC",
            "C01ldHJpY1Byb3RvUAFaPmdvb2dsZS5nb2xhbmcub3JnL2dlbnByb3RvL2dv",
            "b2dsZWFwaXMvbW9uaXRvcmluZy92Mzttb25pdG9yaW5nqgIaR29vZ2xlLkNs",
            "b3VkLk1vbml0b3JpbmcuVjPKAhpHb29nbGVcQ2xvdWRcTW9uaXRvcmluZ1xW",
            "M2IGcHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Google.Api.DistributionReflection.Descriptor, global::Google.Api.LabelReflection.Descriptor, global::Google.Api.MetricReflection.Descriptor, global::Google.Api.MonitoredResourceReflection.Descriptor, global::Google.Cloud.Monitoring.V3.CommonReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Monitoring.V3.Point), global::Google.Cloud.Monitoring.V3.Point.Parser, new[]{ "Interval", "Value" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Monitoring.V3.TimeSeries), global::Google.Cloud.Monitoring.V3.TimeSeries.Parser, new[]{ "Metric", "Resource", "Metadata", "MetricKind", "ValueType", "Points" }, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// A single data point in a time series.
  /// </summary>
  public sealed partial class Point : pb::IMessage<Point> {
    private static readonly pb::MessageParser<Point> _parser = new pb::MessageParser<Point>(() => new Point());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Point> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Monitoring.V3.MetricReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Point() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Point(Point other) : this() {
      interval_ = other.interval_ != null ? other.interval_.Clone() : null;
      value_ = other.value_ != null ? other.value_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Point Clone() {
      return new Point(this);
    }

    /// <summary>Field number for the "interval" field.</summary>
    public const int IntervalFieldNumber = 1;
    private global::Google.Cloud.Monitoring.V3.TimeInterval interval_;
    /// <summary>
    /// The time interval to which the data point applies.  For `GAUGE` metrics,
    /// the start time is optional, but if it is supplied, it must equal the
    /// end time.  For `DELTA` metrics, the start
    /// and end time should specify a non-zero interval, with subsequent points
    /// specifying contiguous and non-overlapping intervals.  For `CUMULATIVE`
    /// metrics, the start and end time should specify a non-zero interval, with
    /// subsequent points specifying the same start time and increasing end times,
    /// until an event resets the cumulative value to zero and sets a new start
    /// time for the following points.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Monitoring.V3.TimeInterval Interval {
      get { return interval_; }
      set {
        interval_ = value;
      }
    }

    /// <summary>Field number for the "value" field.</summary>
    public const int ValueFieldNumber = 2;
    private global::Google.Cloud.Monitoring.V3.TypedValue value_;
    /// <summary>
    /// The value of the data point.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Monitoring.V3.TypedValue Value {
      get { return value_; }
      set {
        value_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Point);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Point other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Interval, other.Interval)) return false;
      if (!object.Equals(Value, other.Value)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (interval_ != null) hash ^= Interval.GetHashCode();
      if (value_ != null) hash ^= Value.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (interval_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Interval);
      }
      if (value_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Value);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (interval_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Interval);
      }
      if (value_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Value);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Point other) {
      if (other == null) {
        return;
      }
      if (other.interval_ != null) {
        if (interval_ == null) {
          Interval = new global::Google.Cloud.Monitoring.V3.TimeInterval();
        }
        Interval.MergeFrom(other.Interval);
      }
      if (other.value_ != null) {
        if (value_ == null) {
          Value = new global::Google.Cloud.Monitoring.V3.TypedValue();
        }
        Value.MergeFrom(other.Value);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (interval_ == null) {
              Interval = new global::Google.Cloud.Monitoring.V3.TimeInterval();
            }
            input.ReadMessage(Interval);
            break;
          }
          case 18: {
            if (value_ == null) {
              Value = new global::Google.Cloud.Monitoring.V3.TypedValue();
            }
            input.ReadMessage(Value);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// A collection of data points that describes the time-varying values
  /// of a metric. A time series is identified by a combination of a
  /// fully-specified monitored resource and a fully-specified metric.
  /// This type is used for both listing and creating time series.
  /// </summary>
  public sealed partial class TimeSeries : pb::IMessage<TimeSeries> {
    private static readonly pb::MessageParser<TimeSeries> _parser = new pb::MessageParser<TimeSeries>(() => new TimeSeries());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TimeSeries> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Monitoring.V3.MetricReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TimeSeries() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TimeSeries(TimeSeries other) : this() {
      metric_ = other.metric_ != null ? other.metric_.Clone() : null;
      resource_ = other.resource_ != null ? other.resource_.Clone() : null;
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      metricKind_ = other.metricKind_;
      valueType_ = other.valueType_;
      points_ = other.points_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TimeSeries Clone() {
      return new TimeSeries(this);
    }

    /// <summary>Field number for the "metric" field.</summary>
    public const int MetricFieldNumber = 1;
    private global::Google.Api.Metric metric_;
    /// <summary>
    /// The associated metric. A fully-specified metric used to identify the time
    /// series.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Api.Metric Metric {
      get { return metric_; }
      set {
        metric_ = value;
      }
    }

    /// <summary>Field number for the "resource" field.</summary>
    public const int ResourceFieldNumber = 2;
    private global::Google.Api.MonitoredResource resource_;
    /// <summary>
    /// The associated monitored resource.  Custom metrics can use only certain
    /// monitored resource types in their time series data.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Api.MonitoredResource Resource {
      get { return resource_; }
      set {
        resource_ = value;
      }
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 7;
    private global::Google.Api.MonitoredResourceMetadata metadata_;
    /// <summary>
    /// Output only. The associated monitored resource metadata. When reading a
    /// a timeseries, this field will include metadata labels that are explicitly
    /// named in the reduction. When creating a timeseries, this field is ignored.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Api.MonitoredResourceMetadata Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "metric_kind" field.</summary>
    public const int MetricKindFieldNumber = 3;
    private global::Google.Api.MetricDescriptor.Types.MetricKind metricKind_ = 0;
    /// <summary>
    /// The metric kind of the time series. When listing time series, this metric
    /// kind might be different from the metric kind of the associated metric if
    /// this time series is an alignment or reduction of other time series.
    ///
    /// When creating a time series, this field is optional. If present, it must be
    /// the same as the metric kind of the associated metric. If the associated
    /// metric's descriptor must be auto-created, then this field specifies the
    /// metric kind of the new descriptor and must be either `GAUGE` (the default)
    /// or `CUMULATIVE`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Api.MetricDescriptor.Types.MetricKind MetricKind {
      get { return metricKind_; }
      set {
        metricKind_ = value;
      }
    }

    /// <summary>Field number for the "value_type" field.</summary>
    public const int ValueTypeFieldNumber = 4;
    private global::Google.Api.MetricDescriptor.Types.ValueType valueType_ = 0;
    /// <summary>
    /// The value type of the time series. When listing time series, this value
    /// type might be different from the value type of the associated metric if
    /// this time series is an alignment or reduction of other time series.
    ///
    /// When creating a time series, this field is optional. If present, it must be
    /// the same as the type of the data in the `points` field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Api.MetricDescriptor.Types.ValueType ValueType {
      get { return valueType_; }
      set {
        valueType_ = value;
      }
    }

    /// <summary>Field number for the "points" field.</summary>
    public const int PointsFieldNumber = 5;
    private static readonly pb::FieldCodec<global::Google.Cloud.Monitoring.V3.Point> _repeated_points_codec
        = pb::FieldCodec.ForMessage(42, global::Google.Cloud.Monitoring.V3.Point.Parser);
    private readonly pbc::RepeatedField<global::Google.Cloud.Monitoring.V3.Point> points_ = new pbc::RepeatedField<global::Google.Cloud.Monitoring.V3.Point>();
    /// <summary>
    /// The data points of this time series. When listing time series, points are
    /// returned in reverse time order.
    ///
    /// When creating a time series, this field must contain exactly one point and
    /// the point's type must be the same as the value type of the associated
    /// metric. If the associated metric's descriptor must be auto-created, then
    /// the value type of the descriptor is determined by the point's type, which
    /// must be `BOOL`, `INT64`, `DOUBLE`, or `DISTRIBUTION`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.Cloud.Monitoring.V3.Point> Points {
      get { return points_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TimeSeries);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TimeSeries other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Metric, other.Metric)) return false;
      if (!object.Equals(Resource, other.Resource)) return false;
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if (MetricKind != other.MetricKind) return false;
      if (ValueType != other.ValueType) return false;
      if(!points_.Equals(other.points_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (metric_ != null) hash ^= Metric.GetHashCode();
      if (resource_ != null) hash ^= Resource.GetHashCode();
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      if (MetricKind != 0) hash ^= MetricKind.GetHashCode();
      if (ValueType != 0) hash ^= ValueType.GetHashCode();
      hash ^= points_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (metric_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metric);
      }
      if (resource_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Resource);
      }
      if (MetricKind != 0) {
        output.WriteRawTag(24);
        output.WriteEnum((int) MetricKind);
      }
      if (ValueType != 0) {
        output.WriteRawTag(32);
        output.WriteEnum((int) ValueType);
      }
      points_.WriteTo(output, _repeated_points_codec);
      if (metadata_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(Metadata);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (metric_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metric);
      }
      if (resource_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Resource);
      }
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      if (MetricKind != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) MetricKind);
      }
      if (ValueType != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ValueType);
      }
      size += points_.CalculateSize(_repeated_points_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TimeSeries other) {
      if (other == null) {
        return;
      }
      if (other.metric_ != null) {
        if (metric_ == null) {
          Metric = new global::Google.Api.Metric();
        }
        Metric.MergeFrom(other.Metric);
      }
      if (other.resource_ != null) {
        if (resource_ == null) {
          Resource = new global::Google.Api.MonitoredResource();
        }
        Resource.MergeFrom(other.Resource);
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::Google.Api.MonitoredResourceMetadata();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      if (other.MetricKind != 0) {
        MetricKind = other.MetricKind;
      }
      if (other.ValueType != 0) {
        ValueType = other.ValueType;
      }
      points_.Add(other.points_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (metric_ == null) {
              Metric = new global::Google.Api.Metric();
            }
            input.ReadMessage(Metric);
            break;
          }
          case 18: {
            if (resource_ == null) {
              Resource = new global::Google.Api.MonitoredResource();
            }
            input.ReadMessage(Resource);
            break;
          }
          case 24: {
            MetricKind = (global::Google.Api.MetricDescriptor.Types.MetricKind) input.ReadEnum();
            break;
          }
          case 32: {
            ValueType = (global::Google.Api.MetricDescriptor.Types.ValueType) input.ReadEnum();
            break;
          }
          case 42: {
            points_.AddEntriesFrom(input, _repeated_points_codec);
            break;
          }
          case 58: {
            if (metadata_ == null) {
              Metadata = new global::Google.Api.MonitoredResourceMetadata();
            }
            input.ReadMessage(Metadata);
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
